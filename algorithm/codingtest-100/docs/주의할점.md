# ⚠️ 주의할 점 정리

## 1. primitive type & referrence type
> 이 둘의 차이와 쓰이는 곳 명확히 알기
- 정수형
- 참조형

---

## 2. 부동소수형

> 부동소수형 데이터를 활용하는 문제 주의 및 분석해보기

- 오차 혀용 범위 언급하는 경우

----

## 3. 컬렉션 프레임워크

###  0) 배열
> 저장할 데이터의 개수가 정해져 있는 경우 사용
- Arrays 클래스의 toString() 메서드로 배열 요소를 출력 -> 디버깅에 활용
- 배열 크기는 변경(새 데이터 삽입, 삭제) 불가능, 기존 데이터의 변경만 가능
- 인덱스를 이용한 배열 요소에 대한 접근, 변경의 시간 복잡도 : O(1)

### 1) 리스트
> 자바의 리스트 == ArrayList
- ArrayList는 가변 크기, 새 데이터의 삽입 or 기존 데이터의 삭제 가능
- 새 데이터 맨 뒤에 추가 시 : 평균 시간 복잡도는 O(1)
- 기존 데이터의 삭제 or 데이터를 중간에 삽입할 때는 시간 복잡도가 O(N)까지 커질 수 있음 주의

```
// 리스트 객체 생성
ArrayList<Integer> list = new ArrayList<>();
// 값 추가
list.add(1);
list.add(2);
list.add(4);
list.add(6); // 리스트의 맨 뒤에 값 추가

System.out.println(list.get(2)); // 4, 인덱스로 값에 접근
```

### 2) 해시맵
> 키를 사용하여 값을 검색하는 자료구조

- 키(key)와 값(value) 쌍을 저장하는 해시 테이블로 구현됨

```
// 해시맵 초기화
HashMap<String, Integer> map = new HashMap<>();

// 해시맵 값 삽입
map.put("apple", 1);
map.put("banana", 2);
map.put("orange", 3);

// 해시맵 값 출력
System.out.println(map); // {banana=2, orange=3, apple=1}

// 해시맵 데이터 검색
String key = "apple";
if (map.containsKey(key)) {
    int value = map.get(key);
    System.out.println(key + " : " + value);    // apple: 1
} else {
    System.out.println(key + "는 해시맵에 없습니다.");
}

// 해시맵 수정
map.put("banana", 4);
System.out.println(map); // {banana=4, orange=3, apple=1}

// 해시맵 삭제
map.remove("orange");
System.out.println(map); // {banana=4, apple=1}
```

### 3) 문자열
> 문자들을 배열의 형태로 구성한 "이뮤터블 객체"

- 값을 변경할 수 없는 객체를 의미, 시간 복잡도 관점에서 사용 시 주의해야 함
- 문자열 추가 시 기존 객체 수정을 하는 것이 아닌 "새로운 객체를 반환 함"
- 문자열 수정 시 "replace()" 메서드를 사용
  - replace(A,B) : replace() 메서드의 대상 문자열에서 A를 모두 찾아 B로 변경하는 것
- String 객체의 값을 변경하는 작업은 새로운 String 객체를 만들고 값을 복사하는 작업이 수행됨을 의미
  - 시간복잡도 O(N) 


### 4) StringBuffer 와 StringBuilder
> 둘다 뮤터블한 객체로 값을 변경할 때 시간 복잡도 관점에서 훨씬 더 효율적임

** 문자열의 시간 복잡도와 StringBuffer, StringBuilder의 관계에 대해 확실히 이해할 것 **

- String의 값을 변경하는 연산이 많을 때 : 효율이 높은 StringBuilder 클래스 or StringBuffer 클래스 이용해야함
- Thread-Safe가 없는 StringBuilder 클래스가 속도 측면에서 미세하지만 더 빠르므로 StringBuilder를 사용하면 됨

```
// StringBuilder 객체 생성
StringBuilder sb = new StringBuilder();

// 문자열 Add
sb.append(10);
sb.append("ABC");

// 출력
System.out.println(sb); // 10ABC
sb.deleteCharAt(3); // 3번째 인덱스 문자 삭제
System.out.println(sb); // 10AC
sb.insert(1,2);         // 1번째 인덱스에 2라는 문자 추가
System.out.println(sb); // 120AC
```

---

## 4. 메서드
> 클래스 내부에 정의한 함수

### 1) 메서드 정의 & 호출

```
public int function_name(int param1, int param2) {
    // 메서드의 실행 코드
    // ...
    // ...
    return result; // 반환값
}
```

```
public static void main(String[] args) {
    // 함수를 호출하여 결과 확인
    int ret = add(5,10);
    System.out.print(ret);
}

public static void int add(int num1, int num2) {
    int result = num1 + num2;
    return result;
}
```

### 2) 람다식
> 익명함수
- 람다식 기본 문법과 사용법, 사용하는 경우 공부하기

---

## 5. 코딩테스트 코드 구현 노하우

### 1) 조기반환(Early Return)
> 코드 실행과정이 함수 끝까지 도달하기 전에 반환하는 기법

### 2) 보호 구문(Guard Clauses)
> 본격적인 로직 진행 전 예외 처리 코드를 추가하는 기법

### 3) 제네릭(Generic)
> 빌드 레벨에서 타입을 체크하여 타입 안정성을 제공 + 타입 체크와 형변환을 생략할 수 있게 해주어 코드를 간결하게 만들어줌

```
List<Integer> genericList = new ArrayList<>();
```
- 타입에 맞지 않는 데이터를 추가하려고 할 때 문법 오류를 발생시켜 개발자의 실수를 방지해줌
- 코테에서 여러 타입의 데이터를 하나의 컬렉션에 넣어야 하는 경우는 거의 없으므로 제네릭으로 타입을 강제하여 실수 방지할 것


